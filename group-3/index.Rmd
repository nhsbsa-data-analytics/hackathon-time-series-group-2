---
title: "Correlation Analysis in Time Series data using R"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

setwd("C:\\Users\\GRPLA\\Documents\\GitHub\\Time-series-training")

# packages for this tutorial
# first approach
library(feasts)
library(tsibble)
library(lubridate)

# second approach
library(TSstudio)
library(plotly)

# third approach
library(tidyverse)
library(timetk)
library(lubridate)

# reading the dataset
stackoverflow_raw <- read_csv("MLTollsStackOverflow.csv")

# selecting columns to use in this tutorial
stackoverflow_tbl <- stackoverflow_raw %>%
  select(month, r, python)

# convert to date
stackoverflow_prep_tbl <- stackoverflow_tbl %>% 
  mutate(date = str_glue("20{month}"),
         date = yearmonth(date) %>% as_date()) %>% 
  select(date, r, python, -month)

# ts function is responsible to convert to ts object
stackOverflow_ts <- ts(data = stackoverflow_prep_tbl[, c("python", "r")], # selecting 2 variables
   start = c(2009, 01), # start date
   end = c(2019, 12), # end date 
   frequency = 12)

stackoverflow_prep_tsbl <- stackoverflow_prep_tbl %>% 
  mutate(date = yearmonth(date)) %>%
  pivot_longer(cols = c(r, python), names_to = "names", values_to = "value") %>% 
  as_tsibble(key = names,index = date) # specifying the time series in the object


```

## https://www.lobdata.com.br/2020/09/15/how-to-perform-correlation-analysis-in-time-series-data-using-r/

# First Approach

The first method that I want to show you use the ts object, a built-in format in R for time series. I choose this approach because with the ts object we have a good integration with TSstudio package and nice interactive functions to use.

### View time series
```{r ts}
ts_info(stackOverflow_ts)
```

### Visualise the time series
```{r vis_ts}
ts_plot(stackOverflow_ts,
        title = "Monthly questions on Stack Overflow platform",
        Ytitle = "# Questions",
        Xtitle = "Year")
```

The time series doesn’t have a seasonal pattern, but it’s possible to see some cyclicality in both time series.

# Lags Analysis I

The TSstudio package doesn’t have any function to plot the ACF and PACF measures, and for that, we use the built-in functions acf and pacf. The downside here, for me, is that the object generated by these functions is not a ggplot2 object, and we lose all beautiful features from the grammar of graphics.

Obviously, you can go through the data and try to plot in the ggplot2 by yourself but will be a little burdensome.

For R time series:

```{r vis_lag_analysis_r}
par(mfrow = c(1, 2))
# acf R time series
stackOverflow_ts[, c("r")] %>% 
  acf(lag.max = 300, 
      main = "Autocorrelation Plot - R")

# pacf R time series
stackOverflow_ts[, c("r")] %>%
  pacf(lag.max = 300,
       main = "Partial Autocorrelation Plot - R")
```

For Python time series:

```{r vis_lag_analysis_python}
par(mfrow = c(1, 2))
# acf Python time series
stackOverflow_ts[, c("python")] %>% 
  acf(lag.max = 300,
      main = "Autocorrelation Plot - Python")

# pacf Python time series
stackOverflow_ts[, c("python")] %>%
  pacf(lag.max = 300,
       main = "Python Autocorrelation Plot - Python")
```

In all graphics we have similar characteristics that need explanation:

* blue lines: These lines are referent to a significance interval, the bars that run through these lines have statistical meaning.
* y-axis: Correlation scores.
* x-axis: Here we have the indication of the lags. Each lag corresponds 12 months, so, almost 11 lags.

Note that looking at ACF plots, both for R and Python time series, we have a greater correlation with more recent lags, which is lost over time. With more distant lags it is possible to see that we have a negative correlation with recent data.

The Partial Autocorrelation is a little different, this “partial” correlation between two variables is the amount of correlation between them which is not explained by their mutual correlations with a specified set of other variables.

For example, if we are regressing a variable Y on other variables X1, X2, and X3, the partial correlation between Y and X3 is the amount of correlation between Y and X3 that is not explained by their common correlations with X1 and X2.

To summarize, when we look at the PACF plot, we want to know each lag that has relevant information to use as a predictor in a future forecast. How much greater the PACF score, the better.

And, in our plots, we see that both time series have one lag (closer to lag 1) that may be useful.

Just know which correlation score has the higher score is not enough, it’s important to see visually how these points are distributed. In that, TSstudio has a great interactive function, called ts_lags.

```{r vis_lag_points}
# Looking at lag plots
ts_lags(stackOverflow_ts,
        lags = c(2, 20, 30, 40, 50, 80)) %>% # choosing what lags to plot
  layout(title = "Series vs Lags")
```

# Causality analysis I

Just look at the past pattern within the series is not always a good idea. The main pitfall of this method is that it will fail whenever the changes in the series derive from the exogenous factors. The goal of causality analysis, in the context of time series analysis, is to identify whether a causality relationship exists between the series we wish to forecast other potential exogenous factors.

Be careful about the fact that correlation doesn’t imply causation, we just looking for something that could help the forecast model. In our current case, we just can see if exist some lag in R time series correlated to Python time series.

```{r ccf_ts}
# ccf time series
par(mfrow=c(1,1))
ccf(stackOverflow_ts[, c("r")], stackOverflow_ts[, c("python")], 
    lag.max = 300,
    main = "Cros-Correlation Plot",
    ylab = "CCF")
```

We see that the higher score is in the recent lags, and some scores between 5 and 10 have a negative relationship.

The graphic is saying to us that currently (at the date of the dataset) the growth of R questions is highly correlated to Python questions.

#Second Approach

This second approach uses what is called tsibble, like a tibble with an implicit date index. So, let’s convert our tibble to a tsibble.


Differently of what we did before, here the data was converted to a long format, better to plot.

Looking at the object created, we see the indication of an interval of these observations [1M] (monthly). And also, we see the key variable, that it’s a way to indicate how many time series exist in this object. It’s possible to have different combinations of features to do a new time series in the object.

As we have the objects ready, we can now perform the correlation analysis by this second approach. Attempt that the graphic interpretation was already made, and here I’ll just explain the difference between the methods.

##Lag Analysis II

Unlike TSstudio, we do not have interactivity plots, all plots are static, but they are objects of ggplot2 and allow us to use the concepts of the grammar of graphics.

A problem with these functions is that they may behave differently than expected. Plugging the data to the acf and pacf functions, we are able to automatically see the faceted plots between all time series within the object. But if we try to simply visualize the series over time, it will not be possible to facet. It’s not a big problem, and you can plot using ggplot normally (see the code).


```{r ts_tibble}
# looking at the data
stackoverflow_prep_tsbl %>% 
  feasts::autoplot()
```

```{r ts_tibble_facet}
# looking at the data facet way
stackoverflow_prep_tsbl %>% 
  ggplot(aes(x = date,
             y = value,
             color = names)) + 
  geom_line() +
  facet_wrap(~names, scales = "free_y")
```

```{r ts_tibble_lag_plot}
# lag plots
stackoverflow_prep_tsbl %>% 
  filter(names == "python") %>% 
  gg_lag(value, geom="point")
```

```{r ts_tibble_acf}
# acf
stackoverflow_prep_tsbl %>% 
  ACF(value, lag_max = 300) %>% 
  autoplot()
```

```{r ts_tibble_pacf}
# pacf 
stackoverflow_prep_tsbl %>% 
  PACF(value, lag_max = 300) %>% 
  autoplot()
```
# Casuality Analysis II

```{r ccf}
# ccf
stackoverflow_prep_tsbl %>% 
  pivot_wider(names_from = names, values_from = value) %>% 
  CCF(python, r, lag_max = 300) %>% 
  autoplot()
```






